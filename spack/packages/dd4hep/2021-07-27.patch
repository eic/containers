diff --git a/CMakeLists.txt b/CMakeLists.txt
index 618812f7..8316ba67 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -46,6 +46,7 @@ ENDIF()
 #############################################################
 
 ENABLE_LANGUAGE(CXX)
+ENABLE_LANGUAGE(C)
 
 # Set C++ standard
 set(CMAKE_CXX_STANDARD 14 CACHE STRING "C++ standard used for compiling")
diff --git a/DDCore/src/plugins/Compact2Objects.cpp b/DDCore/src/plugins/Compact2Objects.cpp
index fab6267f..581f535f 100644
--- a/DDCore/src/plugins/Compact2Objects.cpp
+++ b/DDCore/src/plugins/Compact2Objects.cpp
@@ -805,21 +805,48 @@ template <> void Converter<PropertyTable>::operator()(xml_h e) const {
 }
 #endif
 
-/** Convert compact visualization attribute to Detector visualization attribute
+/** Convert compact visualization attribute to Detector visualization attribute.
  *
  *  <vis name="SiVertexBarrelModuleVis"
  *       alpha="1.0" r="1.0" g="0.75" b="0.76"
  *       drawingStyle="wireframe"
  *       showDaughters="false"
  *       visible="true"/>
+ *
+ *  Optionally inherit an already defined VisAttr and override other properties.
+ *
+ *  <vis name="SiVertexEndcapModuleVis"
+ *       ref="SiVertexBarrelModuleVis"
+ *       alpha="0.5"/>
  */
 template <> void Converter<VisAttr>::operator()(xml_h e) const {
   VisAttr attr(e.attr<string>(_U(name)));
+  float alpha = 1.0;
+  float red   = 1.0;
+  float green = 1.0;
+  float blue  = 1.0;
+  bool use_ref = false;
+  if(e.hasAttr(_U(ref))) {
+    use_ref = true;
+    auto refName = e.attr<string>(_U(ref));
+    const auto refAttr = description.visAttributes(refName);
+    if(!refAttr.isValid() )  {
+        throw runtime_error("reference VisAttr " + refName + " does not exist");
+    }
+    // Just copying things manually.
+    // I think a handle's copy constructor/assignment would reuse the underlying pointer... maybe?
+    refAttr.argb(alpha,red,green,blue);
+    attr.setColor(alpha,red,green,blue);
+    attr.setDrawingStyle( refAttr.drawingStyle());
+    attr.setLineStyle( refAttr.lineStyle());
+    attr.setShowDaughters(refAttr.showDaughters());
+    attr.setVisible(refAttr.visible());
+  }
   xml_dim_t dim(e);
-  float alpha = dim.alpha(1.0);
-  float red   = dim.r(1.0);
-  float green = dim.g(1.0);
-  float blue  = dim.b(1.0);
+  alpha = dim.alpha(alpha);
+  red   = dim.r(red  );
+  green = dim.g(green);
+  blue  = dim.b(blue );
 
   printout(s_debug.visattr ? ALWAYS : DEBUG, "Compact",
            "++ Converting VisAttr  structure: %-16s. Alpha=%.2f R=%.3f G=%.3f B=%.3f",
@@ -835,7 +862,8 @@ template <> void Converter<VisAttr>::operator()(xml_h e) const {
       attr.setLineStyle(VisAttr::DASHED);
   }
   else {
-    attr.setLineStyle(VisAttr::SOLID);
+    if (!use_ref)
+      attr.setLineStyle(VisAttr::SOLID);
   }
   if (e.hasAttr(_U(drawingStyle))) {
     string ds = e.attr<string>(_U(drawingStyle));
@@ -845,12 +873,15 @@ template <> void Converter<VisAttr>::operator()(xml_h e) const {
       attr.setDrawingStyle(VisAttr::SOLID);
   }
   else {
-    attr.setDrawingStyle(VisAttr::SOLID);
+    if (!use_ref)
+      attr.setDrawingStyle(VisAttr::SOLID);
   }
   if (e.hasAttr(_U(showDaughters)))
     attr.setShowDaughters(e.attr<bool>(_U(showDaughters)));
-  else
-    attr.setShowDaughters(true);
+  else {
+    if (!use_ref)
+      attr.setShowDaughters(true);
+  }
   description.addVisAttribute(attr);
 }
 
diff --git a/DDG4/edm4hep/Geant4Output2EDM4hep.cpp b/DDG4/edm4hep/Geant4Output2EDM4hep.cpp
index 555e4e52..504fb8e4 100644
--- a/DDG4/edm4hep/Geant4Output2EDM4hep.cpp
+++ b/DDG4/edm4hep/Geant4Output2EDM4hep.cpp
@@ -20,6 +20,7 @@
 #include "DDG4/Geant4HitCollection.h"
 #include "DDG4/Geant4OutputAction.h"
 #include "DDG4/Geant4SensDetAction.h"
+#include "DDG4/Geant4DataConversion.h"
 #include "DDG4/EventParameters.h"
 
 // Geant4 headers
@@ -563,16 +564,23 @@ void Geant4Output2EDM4hep::createCollections(OutputContext<G4Event>& ctxt){
       continue ;
     }
 
+    Geant4Sensitive* sd = coll->sensitive();
+    string sd_enc = dd4hep::sim::Geant4ConversionHelper::encoding(sd->sensitiveDetector());
+
     if( typeid( Geant4Tracker::Hit ) == coll->type().type()  ){
 
-      m_store->create<edm4hep::SimTrackerHitCollection>(colName);
+      auto& sthc = m_store->create<edm4hep::SimTrackerHitCollection>(colName);
       m_file->registerForWrite(colName);
+      auto& sthc_md = m_store->getCollectionMetaData( sthc.getID() );
+      sthc_md.setValue("CellIDEncodingString", sd_enc);
       printout(DEBUG,"Geant4Output2EDM4hep","+++ created collection %s",colName.c_str() );
     }
     else if( typeid( Geant4Calorimeter::Hit ) == coll->type().type() ){
 
-      m_store->create<edm4hep::SimCalorimeterHitCollection>(colName);
+      auto& schc = m_store->create<edm4hep::SimCalorimeterHitCollection>(colName);
       m_file->registerForWrite(colName);
+      auto& schc_md = m_store->getCollectionMetaData( schc.getID() );
+      schc_md.setValue("CellIDEncodingString", sd_enc);
       printout(DEBUG,"Geant4Output2EDM4hep","+++ created collection %s",colName.c_str() );
 
       colName += "Contributions"  ;
diff --git a/DDG4/src/Geant4ShapeConverter.cpp b/DDG4/src/Geant4ShapeConverter.cpp
index 2a79a69a..6f4af522 100644
--- a/DDG4/src/Geant4ShapeConverter.cpp
+++ b/DDG4/src/Geant4ShapeConverter.cpp
@@ -205,8 +205,9 @@ namespace dd4hep {
 
     template <> G4VSolid* convertShape<TGeoSphere>(const TGeoShape* shape)  {
       const TGeoSphere* sh = (const TGeoSphere*) shape;
-      return new G4Sphere(sh->GetName(), sh->GetRmin() * CM_2_MM, sh->GetRmax() * CM_2_MM, sh->GetPhi1() * DEGREE_2_RAD,
-                          sh->GetPhi2() * DEGREE_2_RAD, sh->GetTheta1() * DEGREE_2_RAD, sh->GetTheta2() * DEGREE_2_RAD);
+      return new G4Sphere(sh->GetName(), sh->GetRmin() * CM_2_MM, sh->GetRmax() * CM_2_MM,
+                          sh->GetPhi1() * DEGREE_2_RAD, (sh->GetPhi2()-sh->GetPhi1()) * DEGREE_2_RAD,
+                          sh->GetTheta1() * DEGREE_2_RAD, (sh->GetTheta2()- sh->GetTheta1()) * DEGREE_2_RAD);
     }
 
     template <> G4VSolid* convertShape<TGeoTorus>(const TGeoShape* shape)  {
