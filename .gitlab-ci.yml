image: eicweb.phy.anl.gov:4567/containers/image_recipes/ubuntu_dind:latest

variables:
  ## Application versions used for the main release 
  ## note: nightly builds will always use the master/main branch
  JUGGLER_VERSION: "v4.0.0"
  NPDET_VERSION: "v1.0.0"
  EICD_VERSION: "v1.0.0"
  DETECTOR_VERSION: "acadia-v1.1"
  IP6_VERSION: "v0.5.2"
  AFTERBURNER_VERSION: "v0.0.2"

  ## Spack github version
  SPACK_VERSION: "a68abc15c5b1b8266130f765d1bee6290e71fa7c"

  ## We need to enable Docker Buildkit to use cache mounts and better
  ## build performance overal
  DOCKER_BUILDKIT: 1

  ## Dockerhub registry
  DH_REGISTRY: eicweb
  DH_PUSH: 1

  ## Also export the raw builder image, will be stored on DH only
  EXPORT_BUILDER: 0

  ## TLS error resiliency: number of retries and second wait between tries 
  ## (wait time is doubled with each attempt)
  DOCKER_NTRIES: 5
  DOCKER_WAIT_TIME: 5

  ## is this nightly or not?
  NIGHTLY: 0

  ## Force a rebuild without using cache
  FORCE_NOCACHE: 0

stages:
  - config
  - build:base      ## base OS image
  - build:dev       ## naked dev container image
  - build:release   ## dressed release container image
  - deploy          ## build/deploy singularity images
  - test            
  - finalize

default:
  before_script:
    - ./gitlab-ci/docker_login.sh -u $DH_REGISTRY -p $DH_EICWEB_TOKEN
                                  -n $DOCKER_NTRIES -t $DOCKER_WAIT_TIME
    - ./gitlab-ci/docker_login.sh --ci -n $DOCKER_NTRIES -t $DOCKER_WAIT_TIME
  after_script:
    - docker logout
    - docker logout ${CI_REGISTRY}

## only run CI for in the following cases:
## master, stable branch, release tag, MR event and nightly builds
## nightly builds are now part of the regular master build in order to keep
## all artifacts available at all times.
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "master"'
    - if: '$CI_COMMIT_BRANCH =~ /^v[0-9]+\.[0-9]+-stable/'          ## main stable branch: vX.Y-stable
    - if: '$CI_COMMIT_BRANCH =~ /^v[0-9]+\.[0-9]+-[a-z]+-stable/'   ## special stable branch: vX.Y-acadia-stable (etc)
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+/'            ## commit tags start with vX.Y.Z with optional suffix

## plan:
##  Workflows:
##  - master      --> config + all build stages + singularity
#                            + nightly build:release + nightly singularity
##  - v3.0-stable --> config + all build stages + singularity
##  - v3.0.0      --> config + all build stages + singularity
##  - MR          --> config + all build stages
##
##  Container images tags
##  - master      --> testing
##  - <nightly>   --> nightly (run as part of master)
##  - v3.0-stable --> 3.0-stable
##  - v3.0.0      --> 3.0-stable, 3.0.0
##  - acadia     
##  - MR          --> 3.0-unstable (on all registries)
##                --> unstable-mr-XXX (on eicweb only, untag at end of pipeline)
##  - all other   --> do nothing
##
## caching strategy for dispatch to multiple nodes and to avoid
##  --> try this strategy: https://medium.com/titansoft-engineering/docker-build-cache-sharing-on-multi-hosts-with-buildkit-and-buildx-eb8f7005918e
##  (first try with buildx didn't pan out, let's try again later)

version:
  stage: config
  script:
    - |
      VERSION=`head -n1 VERSION`
      VERSION_FULL=${VERSION}
      VERSION_SHORT=${VERSION%.*}
      TESTING="testing"
      NIGHTLY="nightly"
    ## determine appropriate major docker tag for this scenario
    - |
      ## internal tag used for the CI. Also temporarily tagged
      ## on eicweb to communicate between jobs (removed in cleanup job)
      INTERNAL_TAG="testing-$VERSION"
      ## main export tag, optional secondary export tag,
      EXPORT_TAG=${TESTING}
      EXPORT_TAG2=
      ## nightly tag, only used in master
      NIGHTLY_TAG=${NIGHTLY}
      if [ "x${CI_PIPELINE_SOURCE}" = "xmerge_request_event" ]; then
        INTERNAL_TAG="unstable-mr-${CI_MERGE_REQUEST_ID}"
        NIGHTLY_TAG="${INTERNAL_TAG}-nightly"
        EXPORT_TAG=${VERSION_SHORT}-unstable
        EXPORT_TAG2=
      elif [[ "$CI_COMMIT_TAG" =~ ^v${VERSION} ]]; then
        VERSION_FULL="${CI_COMMIT_TAG:1}"
        INTERNAL_TAG="stable-tag-${VERSION_FULL}"
        NIGHTLY_TAG=
        EXPORT_TAG=${VERSION_FULL}
        EXPORT_TAG2=
      elif [ "$CI_COMMIT_BRANCH" = "v${VERSION_SHORT}-stable" ]; then
        INTERNAL_TAG="stable-br-${VERSION}"
        NIGHTLY_TAG=
        EXPORT_TAG=${VERSION_SHORT}-stable
        EXPORT_TAG2=
      elif [[ "$CI_COMMIT_BRANCH" =~ ^v${VERSION_SHORT}-[a-z]+-stable ]]; then
        VERSION_FULL="${CI_COMMIT_BRANCH:1}"
        INTERNAL_TAG="stable-br-${VERSION_FULL}"
        NIGHTLY_TAG=
        EXPORT_TAG=${VERSION_FULL}
        EXPORT_TAG2=
      fi
      echo "INTERNAL_TAG=$INTERNAL_TAG" >> build.env
      echo "NIGHTLY_TAG=$NIGHTLY_TAG" >> build.env
      echo "EXPORT_TAG=$EXPORT_TAG" >> build.env
      echo "EXPORT_TAG2=$EXPORT_TAG2" >> build.env
      cat build.env

  artifacts:
    reports:
      dotenv: build.env

## base job for all build jobs. Dependent jobs are expected to set
## the BUILD_IMAGE environment variable, and take care of the actual
## docker build during the "script" step
## note that the nightly builds use a different pipeline
.build:
  rules:
    - when: on_success
  resource_group: build
  ## Use docker runner for docker builds
  tags:
    - docker
  ## cookie-cutter docker push code, to be included at the
  ## end of the regular job scripts
  script:
    - ./gitlab-ci/docker_push.sh -i ${BUILD_IMAGE} -l ${INTERNAL_TAG} 
                                 -n $DOCKER_NTRIES -t $DOCKER_WAIT_TIME
                                 ${EXPORT_TAG} ${EXPORT_TAG2}
    - ./gitlab-ci/docker_push.sh -i ${BUILD_IMAGE} -l ${INTERNAL_TAG} 
                                 -n $DOCKER_NTRIES -t $DOCKER_WAIT_TIME
                                 ${INTERNAL_TAG} --eicweb

## Images:
## debian_base --> jug_dev  --> jug_xl
##             ---------------> jug_sim
##             ---------------> jug_ml

debian_base:default:
  extends: .build
  stage: build:base
  needs:
    - version
  variables:
    BUILD_IMAGE: "debian_base"
  script:
    - docker build -t ${CI_REGISTRY_IMAGE}/${BUILD_IMAGE}:${INTERNAL_TAG} 
                   containers/debian
    - !reference [.build, script]

jug_dev:default:
  extends: .build
  stage: build:dev
  needs:
    - version
    - debian_base:default
  variables:
    BUILD_IMAGE: "jug_dev"
  script:
    ## calculate a hash based on the spack.yaml file and the spack directory
    ## and use this spack as a docker variable to force a rebuild when there
    ## is a change (versus rerun from cache)
    - PACKAGE_HASH=$(tar cf - spack* | sha1sum | head -c40)
    - echo "PACKAGE_HASH= ${PACKAGE_HASH}"
    ## move spacke directory and spack.yaml into the container build directory
    - cp -r spack containers/jug
    - cp -r spack.yaml containers/jug/spack/spack.yaml
    - |
      if [ $FORCE_NOCACHE = 1 ]; then
        echo "FORCE_NOCACHE set"
        export PACKAGE_HASH=`date +%s`
      fi   
    ## Optionally build the raw builder image
    - test ${EXPORT_BUILDER} = 1 && docker build 
                   -t ${CI_REGISTRY_IMAGE}/${BUILD_IMAGE}:builder-${INTERNAL_TAG} 
                   --target=builder
                   -f containers/jug/dev.Dockerfile
                   --build-arg SPACK_VERSION=${SPACK_VERSION}
                   --build-arg CACHE_BUST=${PACKAGE_HASH}
                   --build-arg INTERNAL_TAG=${INTERNAL_TAG}
                   --build-arg JUG_VERSION=${INTERNAL_TAG}-$(git rev-parse HEAD)
                   containers/jug
    ## now build our image
    - docker build -t ${CI_REGISTRY_IMAGE}/${BUILD_IMAGE}:${INTERNAL_TAG} 
                   -f containers/jug/dev.Dockerfile
                   --build-arg SPACK_VERSION=${SPACK_VERSION}
                   --build-arg CACHE_BUST=${PACKAGE_HASH}
                   --build-arg INTERNAL_TAG=${INTERNAL_TAG}
                   --build-arg JUG_VERSION=${INTERNAL_TAG}-$(git rev-parse HEAD)
                   containers/jug
    ## push builder image do DH if desired
    - test ${EXPORT_BUILDER} = 1 && ./gitlab-ci/docker_push.sh 
                                 -i ${BUILD_IMAGE} -l builder-${INTERNAL_TAG}
                                 -n ${DOCKER_NTRIES} -t ${DOCKER_WAIT_TIME}
                                 builder-${EXPORT_TAG} --dockerhub
    ## standard exports
    - !reference [.build, script]

jug_xl:default:
  extends: .build
  stage: build:release
  resource_group: build
  needs:
    - version
    - jug_dev:default
  variables:
    BUILD_IMAGE: "jug_xl"
  script:
    - docker build -t ${CI_REGISTRY_IMAGE}/${BUILD_IMAGE}:${INTERNAL_TAG} 
                   -f containers/jug/xl.Dockerfile
                   --build-arg INTERNAL_TAG=${INTERNAL_TAG}
                   --build-arg JUGGLER_VERSION=${JUGGLER_VERSION}
                   --build-arg NPDET_VERSION=${NPDET_VERSION}
                   --build-arg EICD_VERSION=${EICD_VERSION}
                   --build-arg AFTERBURNER_VERSION=${AFTERBURNER_VERSION}
                   --build-arg DETECTOR_VERSION=${DETECTOR_VERSION}
                   --build-arg IP6_VERSION=${IP6_VERSION}
                   --build-arg JUG_VERSION=${INTERNAL_TAG}-$(git rev-parse HEAD)
                   containers/jug
    - !reference [.build, script]

jug_xl:nightly:
  extends: .build
  stage: build:release
  rules:
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: on_success
    - when: never
  needs:
    - version
    - jug_dev:default
  variables:
    BUILD_IMAGE: "jug_xl"
  script:
    - docker build -t ${CI_REGISTRY_IMAGE}/${BUILD_IMAGE}:${NIGHTLY_TAG} 
                   -f containers/jug/xl.Dockerfile
                   --build-arg INTERNAL_TAG=${INTERNAL_TAG}
                   --build-arg JUG_VERSION=nightly-$(date +%Y-%m-%d_%H-%M-%S)-${INTERNAL_TAG}-$(git rev-parse HEAD)
                   containers/jug
    - |
      PUSH_FLAG=""
      if [ "$CI_PIPELINE_SOURCE" == "merge_request_event" ]; then
        PUSH_FLAG="--eicweb"
      fi
    - ./gitlab-ci/docker_push.sh -i ${BUILD_IMAGE} -l ${NIGHTLY_TAG} 
                                 -n $DOCKER_NTRIES -t $DOCKER_WAIT_TIME
                                 ${NIGHTLY_TAG} ${PUSH_FLAG}

.singularity:
  stage: deploy
  interruptible: true
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: never
    - when: on_success
  artifacts:
      expire_in: 1 days
      paths:
        - build/${BUILD_IMAGE}.sif
  script:
    - mkdir build
    - singularity pull build/${BUILD_IMAGE}.sif docker://${CI_REGISTRY_IMAGE}/${BUILD_IMAGE}:${INTERNAL_TAG}

jug_dev:singularity:default:
  extends: .singularity
  needs: 
    - version
    - jug_dev:default
  variables:
    BUILD_IMAGE: "jug_dev"

jug_xl:singularity:default:
  extends: .singularity
  needs: 
    - version
    - jug_xl:default
  variables:
    BUILD_IMAGE: "jug_xl"

## trigger juggler rebuild on nightly schedule to ensure both images remain in sync
juggler:master:
  stage: deploy
  rules:
    - if: '$NIGHTLY != "0" && $CI_COMMIT_BRANCH == "master"'
      when: on_success
    - when: never
  needs:
    - version
    - jug_xl:nightly
  variables:
    TRIGGERED_BY_NIGHTLY: 1
    JUGGLER_VERSION: master
    EICD_VERSION: master
    NPDET_VERSION: master
    DETECTOR_VERSION: master
    IP6_VERSION: master
  trigger:
    project: EIC/juggler
  allow_failure: true

cleanup:
  stage: finalize
  dependencies:
    - version
  script:
    ## remove the pipeline specific export from eicweb if needed
    - echo "Cleaning up pipeline specific docker tags if needed"
    - ./gitlab-ci/cleanup_registry.sh -i debian_base -r 66 ${INTERNAL_TAG}
    - ./gitlab-ci/cleanup_registry.sh -i jug_dev -r 68 ${INTERNAL_TAG}
    - ./gitlab-ci/cleanup_registry.sh -i jug_xl -r 69 ${INTERNAL_TAG}
    - |
      if [ "$CI_PIPELINE_SOURCE" == "merge_request_event" ]; then
        ./gitlab-ci/cleanup_registry.sh -i jug_xl -r 69 ${NIGHTLY_TAG}
      fi
